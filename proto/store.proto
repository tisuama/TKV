syntax="proto2";
import "common.proto";
import "meta.proto";
import "optype.proto";
package TKV.pb;
option cc_generic_services = true;

message RegionLeader {
    required int64 region_id = 1;
    required string leader = 2;
};

message RemoveRegion {
    required int64 region_id = 1;
    optional bool  force = 2;
    optional bool  need_delay_drop = 3;
};

message RegionRaftStats {
    optional int64  applied_index = 1;
    optional uint64 snapshot_data_size = 2;
    optional uint64 snapshot_meta_size = 3;
    optional int64  snapshot_index = 4;
    optional int64  dml_latency = 5;
};

message StoreRes {
    required ErrorCode       errcode = 1;
    optional bytes           errmsg  = 2;
    optional string          leader = 3;
    repeated RegionInfo      regions = 4;
    optional int64           applied_index = 5;
    optional int32           last_seq_id = 6;   // 事务已执行的最后一个cmd的seq_id
    optional int64           region_count = 7;
    repeated RegionLeader    region_leaders = 8;
    optional bool            is_merge = 9;
    optional PeerStatus      region_status = 10;
    optional RegionRaftStats region_raft_stat = 11;
    repeated KvOp            kv_pairs = 12;
    repeated TransactionInfo txn_infos = 16;
    optional int64           affected_rows = 17;
};

message KvOp {
    optional string      key = 1;
    optional string      value = 2;
    optional BatchOpType batch_type = 3;
    optional int64       ttl_timestamp_us = 4;
};

enum TxnState {
    TXN_UNKNOW     = 0;
    TXN_BEGINED    = 1;
    TXN_PREPARED   = 2;
    TXN_COMMITTED  = 3;
    TXN_ROLLBACKED = 4;
};

message CachePlan {
    required OpType      op_type = 1;
    required int32       seq_id  = 2;
    repeated KvOp        kv_ops  = 3;
    // store哪些region用来commit，用来txn的恢复
    repeated RegionInfo  regions = 4;
};

message TransactionInfo {
    required uint64     txn_id = 1;
    required int32      seq_id = 2;
    optional int32      start_seq_id = 3;
    optional bool       optimize_1pc = 4;
    repeated int32      need_rollback_seq = 5;
    optional int64      num_rows = 6;
    optional bool       autocommit = 7;
    optional int64      primary_region_id = 8;
    optional TxnState   txn_state = 9;
    optional int64      live_time = 10;
    optional int64      start_ts = 11;
    optional int64      commit_ts = 12;
    optional int64      txn_timeout = 13;
    optional bool       need_update_primary_ts = 14;
    repeated CachePlan  cache_plans = 15;
};

message StoreReq {
    required OpType op_type = 1;
    required int64  region_id = 2;
    required int64  region_version = 3;
    optional int64  log_id = 4;
    optional bytes  start_key = 5;
    optional bytes  end_key = 6;
    optional int64  split_term = 7;
    optional int64  split_end_index = 8;
    optional int64  reduce_num_lines = 9;       // split需要删除的行数
    optional bool   force = 10;
    optional bool   not_check_region = 11;      // 不判断数据与region的匹配性
    optional RegionInfo new_region_info = 12;
    optional bool   select_without_leader = 13;  // selcet 不判断Leader
    optional int64  num_increase_rows = 14;
    repeated KvOp   kv_ops = 15;
    repeated TransactionInfo txn_infos = 16;
    optional uint64 client_id = 17;
};

message InitRegion {
    required RegionInfo region_info = 1;
    optional SchemaInfo schema_info = 2;
    optional bool       is_split = 3;
    // 初始化时需要snapshot的次数
    optional int32      snapshot_times = 4;
    optional bool       is_learner = 5;
};

message GetAppliedIndex {
    required int64 region_id = 1;
};

service StoreService {
    rpc init_region(InitRegion) returns (StoreRes);
    // 1) 获取region的applied_index，用来分裂后优化选择transfer leader对象
    // 2) 获取region的snapshot数据大小，用作校验
    rpc get_applied_index(GetAppliedIndex) returns (StoreRes);
    rpc query(StoreReq) returns (StoreRes);
};
/* vim: set expandtab ts=4 sw=4 sts=4 tw=100: */
